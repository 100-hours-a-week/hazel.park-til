## 🗓️ 2025-01-20

### 🐌 스크럼

- 학습 목표 1. 슬라이딩 윈도우와 deque를 활용한 최솟값 탐색

### 💡 새로 배운 내용

#### 1. 슬라이딩 윈도우

- 배열이나 리스트에서 고정된 크기의 구간을 이동시키며 특정 연산을 수행하는 기법
- 연속된 구간에서 최소/최대값, 합, 곱을 효율적으로 계산할 수 있음
- 구간을 이동할 때 전체를 다시 계산하지 않고 이전 상태를 활용하여 계산량을 줄임
- ⏰ O(N)

#### 2. Deque (Double-Ended Queue)

양쪽(앞,뒤)에서 삽입, 삭제가 가능한 자료구조 <br>

💻 알고리즘 문제: BOJ 11003

문제 설명

- 길이가 N 인 수열 A 가 주어진다.
- 각 i -번째 값 D[i] 는 A[i-L+1] 부터 A[i] 사이의 최솟값을 의미한다.
- 단, i - L + 1 <= 0 인 경우, A[i-L+1] 는 무시하고 최솟값을 계산한다.

코드

```cpp
deque<int> dq; // 최솟값 인덱스 관리 (슬라이딩 윈도우)
vector<int> result; // 최솟값 저장

for (int i = 0; i < N; i++) {

    // 슬라이딩 윈도우의 맨 앞 인덱스
    // 슬라이딩 윈도우가 이동하면서 오래된 인덱스를 제거함
    if (!dq.empty() && dq.front() < i - L + 1) {
        dq.pop_front();
    }

    // 슬라이딩 윈도우의 맨 뒤 인덱스
    // 현재 배열의 값보다 큰 값은 제거
    // 현재 값보다 큰 값이 슬라이더에 있으면
    // 어차피 걔는 최솟값이 못 됨
    while (!dq.empty() && A[dq.back()] > A[i]) {
        dq.pop_back();
    }

    dq.push_back(i);
    result.push_back(A[dq.front()]);
}
```

### 👏🏻 오늘의 회고

- 슬라이딩 윈도우 기법을 배울 수 있었다. 앞으로 다른 문제에서도 특정 구간이 정해져있는 탐색 문제라면 이 알고리즘을 사용해봐야겠다.

### 🔗 참고 자료 및 링크

- [슬라이딩 윈도우 레퍼런스](https://velog.io/@ninto_2/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
