## 🗓️ 2024-11-06

### 🐌 스크럼

- 학습 목표 1. 웹 응용 복습
- 학습 목표 2. 딥다이브

### 💡 새로 배운 내용

#### 1. 조건부 요청 헤더

클라이언트가 서버로 요청을 보낼 때, 헤더에 특정 조건을 붙여 해당 조건을 만족할 때만 응답을 반환하도록 하는 방식

- 사용 이유

  - 주로 만료된 캐시를 리프레시 하기 위해 사용

- 장점

  - 불필요한 데이터 전송을 하지 않는다.
  - 서버의 자원 낭비를 예방할 수 있다.

- 종류
  - `If-Modified-Since` : 서버에서 리소스가 특정 날짜 이후에 수정되었을 때만 응답을 받겠다.
  - `If-Unmodified-Since` : 서버에서 리소스가 특정 날짜 이후에 수정되지 않았을 때만 응답을 받겠다.
  - `If-None-Match` : 서버 리소스의 ETag와 현재 캐시의 ETag가 일치하지 않으면 응답을 받겠다.
  - `If-Match` : 서버의 리소스의 ETag와 현재 캐시의 ETag가 일치하면 응답을 받겠다.

#### 2. 사용자 인증 방식 (Cookie vs Cookie, Session vs JWT)

HTTP의 **stateless, connectionless**한 특성에서 사용자를 인증하는 방식들

#### 2-1. Cookie

사용자가 웹 사이트에 방문했을 때, 서버로부터 받는 작은 정보 파일 <br />
클라이언트가 서버에 보낼 때마다 사용한다.

- 특징 ~~인데 단점밖에 없는~~
  - 보안에 취약하다. (요청시 쿠키값이 노출됨)
  - 쿠키의 용량이 작다.

#### 2-2. Cookie, Session

쿠키만 사용하면 위와 같은 단점이 존재하기 때문에, 세션을 같이 이용하는 방식이 등장하였다. <br />
클라이언트의 인증 정보는 서버의 세션에 저장하고 해당 세션의 ID를 쿠키에 담아 클라이언트에게 전송한다.

- 특징
  - 쿠키가 노출되어도 노출에 타격이 없는 세션 ID이기 때문에 괜찮다.
  - 서버에서 세션 저장소를 사용하고 있기 때문에, 많은 사용자들이 이용하는 경우에는 서버 부하가 심해진다.

#### 2-3. JWT

JSON Web Token, 정보를 JSON 객체로 안전하게 전송한다. <br />
Header, Payload, Signature의 조합으로 이루어져 있다. <br />
서버는 클라이언트의 로그인 요청이 들어오면 payload에 해당 데이터들을 넣고 Token을 반환해준다. <br />
클라이언트는 해당 Token을 저장해두고 `Authorization` 헤더에 담아 서버와 통신한다.

- 특징
  - 서버에 별도의 저장소가 필요하지 않다. > 서버 부담 ↓
  - 토큰을 기반으로 다른 시스템에 접근 및 권한 공유가 가능하다. > 확장성 ↑
  - 다만 토큰의 길이가 길어서 인증 요청이 많을수록 네트워크 부하가 심해지고
  - 토큰이 탈취당해도 서버에서 강제로 만료시킬 수 없는 단점이 있다. > 쿠키/세션은 서버에서 직접 쉽게 삭제할 수 있다.

### 👩🏻‍💻 오늘의 도전 과제와 해결 방법

- 조건부 요청 헤더를 주제로 딥다이브 하기
- 사용자 인증 방식에 대해 더 공부하기

### 👏🏻 오늘의 회고

- 현재 커뮤니티 과제 서버에서 쿠키, 세션을 이용한 사용자 인증 방식을 구현하려 하는데 에러가 나서 골치가 아픈 상황이다. 그러던 중 팀원 분들의 딥다이브 주제로 JWT vs Cookie, Session이 있었는데 재미있기도 했고, 혹시 에러의 원인을 알 수 있을까 하는 마음에 관련 공부를 더 해보았다. 그래도 원인은 모르겠다. 🤯

### 🔗 참고 자료 및 링크

- [hazel 조건부 요청 헤더 딥다이브 ](https://www.notion.so/adapterz/d77495f3e7c74f68bbdeb54bdfa5e2d8?v=130394a4806181819bff000c88fbdca8&p=f00e4936f12b41dc981f6bcfc0322f47&pm=s)
- [인증 방식 레퍼런스](https://tecoble.techcourse.co.kr/post/2021-05-22-cookie-session-jwt/)
